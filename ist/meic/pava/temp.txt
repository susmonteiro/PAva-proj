/*public static class ClassMethodCombination {
        private CtClass ctClass;
        private CtMethod ctMethod;
        private String value;
        private String originalName;

        public ClassMethodCombination() {
        }

        public ClassMethodCombination(CtClass ctClass, CtMethod ctMethod, String value, String originalName) {
            this.ctClass = ctClass;
            this.ctMethod = ctMethod;
            this.value = value;
            this.originalName = originalName;
        }

        public CtClass ctClass() {
            return this.ctClass;
        }

        public CtMethod ctMethod() {
            return this.ctMethod;
        }

        public String value() {
            return this.value;
        }

        public String originalName() {
            return this.originalName;
        }

        @Override
        public String toString() {
            return "Method <" + ctMethod.getName() + "> from Class <" + ctClass.getName() + "> with the value \""
                    + value + "\"";
        }

        @Override
        public int hashCode() {
            return this.ctMethod().getLongName().hashCode();
        }

        @Override
        public boolean equals(final Object o) {
            if (!(o instanceof ClassMethodCombination))
                return false;

            ClassMethodCombination other = (ClassMethodCombination) o;
            return this.ctClass() == other.ctClass()
                    && this.ctMethod().getLongName().equals(other.ctMethod().getLongName())
                    && this.value() == other.value();
        }
    }

    public static class Tuple {
        private String ctMethod;
        private String value;

        public Tuple() {
        }

        public Tuple(String ctMethod, String value) {
            this.ctMethod = ctMethod;
            this.value = value;
        }

        public String ctMethod() {
            return this.ctMethod;
        }

        public String value() {
            return this.value;
        }
    }

    private static final Map<String, String> operations = Map.of("or", " || ", "and", " && ");

    public void start(ClassPool pool) throws NotFoundException, CannotCompileException {

    }

    public void onLoad(ClassPool pool, String className) throws NotFoundException, CannotCompileException {
        CtClass ctClass = pool.get(className);
        try {
            combineMethods(ctClass);
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        }
    }

    // Retrieve all the reachable methods from a given class

    static void getAllMethods(CtClass originalClass, CtClass ctClass, List<ClassMethodCombination> allMethodsOut)
            throws NotFoundException, ClassNotFoundException, CannotCompileException {

                
        for (CtClass ctInterface : ctClass.getInterfaces()) {
            getAllMethods(originalClass, ctInterface, allMethodsOut);
            getMethodsWithAnnotation(originalClass, ctInterface, allMethodsOut);
        }

        CtClass superclass = ctClass.getSuperclass();
        if (superclass != null) {
            getAllMethods(originalClass, superclass, allMethodsOut);
            getMethodsWithAnnotation(originalClass, superclass, allMethodsOut);
        }
    }

    static void getMethodsWithAnnotation(CtClass originalClass, CtClass ctClass,
            List<ClassMethodCombination> allMethodsOut) throws ClassNotFoundException, CannotCompileException {

        for (CtMethod ctMethod : ctClass.getDeclaredMethods()) {
            for (Object annotation : ctMethod.getAnnotations()) {
                if (annotation instanceof Combination) {
                    String fixedName = ctMethod.getName().split("$")[0];
                    System.out.println("Add method " + fixedName + " to class " + originalClass.getName());
                    CtMethod newMethod = CtNewMethod.copy(ctMethod, fixedName + "$" + ctClass.getName(), originalClass, null);
                    Combination combination = (Combination) annotation;
                    allMethodsOut.add(new ClassMethodCombination(ctClass, newMethod, combination.value(), fixedName));
                }
            }        
        }
    }

    static Map<Tuple, List<ClassMethodCombination>> groupMethods(List<ClassMethodCombination> CMCs) {
        return CMCs.stream().collect(Collectors.groupingBy(cmc -> new Tuple(cmc.ctMethod().getName(), cmc.value())));
    }

    static void combineMethods(CtClass ctClass)
            throws ClassNotFoundException, CannotCompileException, NotFoundException {
        // debug
        // System.out.println("Class: " + ctClass.getName());

        List<ClassMethodCombination> allMethods = new ArrayList<ClassMethodCombination>();
        getAllMethods(ctClass, ctClass, allMethods);
        Map<Tuple, List<ClassMethodCombination>> methodsGrouped = groupMethods(
            allMethods.stream().distinct().collect(Collectors.toList())
        );

        for (Map.Entry<Tuple, List<ClassMethodCombination>> group : methodsGrouped.entrySet()) {
            combine(ctClass, group.getValue(), group.getKey().value());
        }
        // System.out.println("\n==================================\n" + ctClass.getName());
        // for (ClassMethodCombination classMethodCombination : allMethods.stream().distinct()
        //         .collect(Collectors.toList()))
        //     System.out.println(classMethodCombination);

        // printMethods(ctClass, true);
    }

    // ! debug function, remove me
    static void printMethods(CtClass ctClass, boolean annot) throws ClassNotFoundException {
        System.out.println("Class: " + ctClass.getName() + " -> Methods:");

        for (CtMethod ctMethod : ctClass.getDeclaredMethods()) {
            System.out.println(ctMethod.getName());
            Object[] annotations = ctMethod.getAnnotations();
            if (annot && annotations.length != 0)
                System.out.println("\tAnnotation: " + annotations[0]);
        }
    }

    static CtMethod getCtMethod(CtClass ctClass, String name, String longName) {
        try {
            return ctClass.getMethod(name, longName);
        } catch (NotFoundException e) {
            return null;
        }
    }

    static CtMethod getCtDeclaredMethod(CtClass ctClass, String name, CtClass[] parameters) {
        try {
            return ctClass.getDeclaredMethod(name, parameters);
        } catch (NotFoundException e) {
            return null;
        }
    }

    static void combine(CtClass ctClass, List<ClassMethodCombination> groupOfMethods, String value)
            throws CannotCompileException, NotFoundException, ClassNotFoundException {

        if (value.equals("standard"))
            // combineStandard(ctClass, ctMethod, value);
            System.out.println("Combine Standard");

        else if (operations.containsKey(value)) {
            combineSimple(ctClass, groupOfMethods);
            // System.out.println("Combine Simple");
        } else {
            System.err.println("Valid operations are 'or', 'and' and 'standard'");
            System.exit(1);
        }
    }

    static void combineSimple(CtClass ctClass, List<ClassMethodCombination> CMCs)
            throws CannotCompileException, NotFoundException, ClassNotFoundException {

                
        ClassMethodCombination first = CMCs.get(0);
        CtMethod oneMethod = first.ctMethod();
        String operation = operations.get(first.value());
        CtMethod ctMethod;
        System.out.println("Combine simple for class " + ctClass.getName());

        String body = "{ return ";
        for (ClassMethodCombination cmc : CMCs) {
            String name = cmc.ctMethod().getName();
            System.out.println("\tAdd " + cmc.ctMethod().getName() + " to " + ctClass.getName());

            ctClass.addMethod(cmc.ctMethod());

            body += name + "($$)" + operation;
        }

        ctMethod = getCtDeclaredMethod(ctClass, first.originalName(), oneMethod.getParameterTypes());
        // System.out.println("CT METHOD "+ ctMethod.getName());
        if (ctMethod == null) {
            // method does not exist yet
            ctMethod = CtNewMethod.copy(oneMethod, first.originalName(), ctClass, null);
            System.out.println("\tAdd method " + first.originalName() + " to class " + ctClass.getName());
            body = body.substring(0, body.length() - operation.length()) + "; }";
        } else {
            ctMethod.setName(first.originalName() + "$original");
            ctMethod = CtNewMethod.copy(ctMethod, first.originalName(), ctClass, null);
            body += first.originalName() + "($$); }";
        }
        
        System.out.println("\t" + body);


        ctMethod.setBody(body);
        ctClass.addMethod(ctMethod);
    }

    static void combineStandard(CtClass ctClass, CtMethod ctMethod, String value)
            throws CannotCompileException, NotFoundException, ClassNotFoundException {
        // todo implement
    }*/




========== [ CombineReachability ] ==========

Worker          { Worker }
HardWorker      { HardWorker, Worker }
NotHardWorker   { NotHardWorker, Worker }

Person          { Person, }
Student         { Student, NotHardWorker, Worker, Person }
ISTStudent      { ISTStudent, HardWorker, Worker, Student, NotHardWorker, Person }













class CombineMethodList {
    CtClass originalClass;
    Map<String, CombineMethod> combineMethods = new HashMap<String, CombineMethod>();

    public CombineMethodList(CtClass ctClass) throws NotFoundException, ClassNotFoundException {
        this.originalClass = ctClass;
        getAllMethods(ctClass);

        System.out.println("========== [ " + ctClass.getName() + " ] ==========");
        for (Map.Entry<String, CombineMethod> entry : this.combineMethods.entrySet())
            System.out.println(entry.getValue());
    }

    private Map<String, Set<CtClass>> getAllMethods(CtClass ctClass) throws NotFoundException, ClassNotFoundException {
        Map<String, Set<CtClass>> combineReachabilities = new HashMap<String, Set<CtClass>>();
        for (CtClass ctInterface : ctClass.getInterfaces())
            mergeCombineReachabilities(ctClass, combineReachabilities, getAllMethods(ctInterface));

        getCombineMethods(ctClass, combineReachabilities);
        CtClass superclass = ctClass.getSuperclass();
        if (superclass != null)
            mergeCombineReachabilities(ctClass, combineReachabilities, getAllMethods(superclass));

        updateCombineReachabilities(ctClass, combineReachabilities);
        return combineReachabilities;
    }

    private void getCombineMethods(CtClass ctClass, Map<String, Set<CtClass>> outCombineReachabilities)
            throws ClassNotFoundException {

        for (CtMethod ctMethod : ctClass.getDeclaredMethods()) {
            for (Object annotation : ctMethod.getAnnotations()) {
                if (annotation instanceof Combination) {
                    String fixedMethodName = getFixedMethodName(ctMethod.getName());
                    processCombineMethod(fixedMethodName, ctMethod, (Combination) annotation);
                    addClassToCombineReachabilities(fixedMethodName, ctClass, outCombineReachabilities);
                }
            }
        }
    }

    private void processCombineMethod(String fixedMethodName, CtMethod ctMethod, Combination annotation) {
        CombineMethod combineMethod = this.combineMethods.get(fixedMethodName);
        if (combineMethod != null)
            testCombineMethod(combineMethod, ctMethod, annotation);
        else
            addCombineMethod(fixedMethodName, ctMethod, annotation);
    }

    private void testCombineMethod(CombineMethod combineMethod, CtMethod ctMethod, Combination annotation) {
        if (!combineMethod.getCombineInfo().getValue().equals(annotation.value()))
            throw new RuntimeException("Error: Combine method <" + ctMethod.getLongName() +
                    "> must not have two different combination values!");
        if (!combineMethod.getSignature().equals(ctMethod.getSignature()))
            throw new RuntimeException("Error: Combine method <" + ctMethod.getLongName() +
                    "> must not have two different signatures!");
    }

    private void addCombineMethod(String fixedMethodName, CtMethod ctMethod, Combination annotation) {
        CombineInfo combineInfo = new CombineInfo(annotation.value());
        CombineMethod combineMethod = new CombineMethod(fixedMethodName, ctMethod.getSignature(), combineInfo);
        this.combineMethods.put(ctMethod.getName(), combineMethod);
    }

    private String getFixedMethodName(String name) {
        return name.split("$")[0];
    }

    private void mergeCombineReachabilities(CtClass ctClass, Map<String, Set<CtClass>> outCombineReachabilities,
            Map<String, Set<CtClass>> newCombineReachabilities) {

        for (Map.Entry<String, Set<CtClass>> entry : newCombineReachabilities.entrySet()) {
            Set<CtClass> combineReachability = outCombineReachabilities.get(entry.getKey());
            if (combineReachability == null) {
                combineReachability = entry.getValue();
                outCombineReachabilities.put(entry.getKey(), combineReachability);
            } else {
                combineReachability.addAll(entry.getValue());
            }

            combineReachability.add(ctClass);
        }
    }

    private void updateCombineReachabilities(CtClass origin, Map<String, Set<CtClass>> combineReachabilities) {
        for (Map.Entry<String, Set<CtClass>> entry : combineReachabilities.entrySet())
            for (CtClass target : entry.getValue())
                this.combineMethods.get(entry.getKey()).addReachableClass(origin, target);
    }

    private void addClassToCombineReachabilities(String name, CtClass ctClass,
            Map<String, Set<CtClass>> outCombineReachabilities) {

        Set<CtClass> combineReachability = outCombineReachabilities.get(name);
        if (combineReachability == null) {
            combineReachability = new HashSet<CtClass>();
            outCombineReachabilities.put(name, combineReachability);
        }

        combineReachability.add(ctClass);
    }
}

class CombineMethod {
    String name;
    String signature;
    CombineInfo combineInfo;
    Map<CtClass, Set<CtClass>> combineReachability;

    public CombineMethod(String name, String signature, CombineInfo combineInfo) {
        this.name = name;
        this.signature = signature;
        this.combineInfo = combineInfo;
        this.combineReachability = new HashMap<CtClass, Set<CtClass>>();
    }

    public String getName() {
        return name;
    }

    public String getSignature() {
        return signature;
    }

    public CombineInfo getCombineInfo() {
        return combineInfo;
    }

    public Map<CtClass, Set<CtClass>> combineReachability() {
        return combineReachability;
    }

    public void addReachableClass(CtClass origin, CtClass target) {
        Set<CtClass> originReachability = this.combineReachability.get(origin);
        if (originReachability == null) {
            originReachability = new HashSet<CtClass>();
            this.combineReachability.put(origin, originReachability);
        }

        originReachability.add(target);
    }

    @Override
    public String toString() {
        String combineReachabilityStr = "";
        for (Map.Entry<CtClass, Set<CtClass>> entry : this.combineReachability.entrySet()) {
            combineReachabilityStr += ", {" + entry.getKey().getName() + "={";
            combineReachabilityStr += entry.getValue().stream()
                    .map(c -> c.getName())
                    .reduce("", (str, c) -> (str + ", " + c))
                    .replaceFirst(", ", "");
            combineReachabilityStr += "}}";
        }

        combineReachabilityStr = combineReachabilityStr.replaceFirst(", ", "");
        return "CombineMethod{name=\'" + this.name +
                "\', signature=\'" + this.signature +
                "\', combineInfo=" + this.combineInfo +
                "\', combineRechability=[" + combineReachabilityStr +
                "}]";
    }
}

class CombineInfo {
    String value;

    public CombineInfo(String value) {
        this.value = value;
    }

    public String getValue() {
        return value;
    }

    @Override
    public String toString() {
        return "CombineInfo{value=\'" + this.value + "\'}";
    }
}